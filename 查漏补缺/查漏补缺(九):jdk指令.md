# 常用jdk指令
- jps:查看JVM里运行的所有进程信息
- jstack：生成一个java进程内的线程快照，包括线程的状态，调用栈，都可以看到
- jstat：查看java堆中的内存情况，包括各分区的占用大小，gc进行的次数
- jmap：查看JVM堆中的对象的情况，包括对象的数量，占用内存大小等数据，一般的用法可以加上一个dump参数来生成文件，然后放到第三方软件上去查看对象的情况，比如说我用过jprofiler，它可以图形化对象情况，分析一些内存泄漏问题就很直观。

# Spring的一个线程安全
Spring它内部没有任何的一些维护线程安全的措施，并且IOC容器中的bean默认是单例的，在bean内部的一些共享变量，在多线程的环境下是会有线程安全的问题的。这个时候其实可以用ThreadLocal来保障线程安全。

# 什么时候需要自定义类加载器？
一般我们接触最多的应该是应用类加载器，它就负责CLASS_PATH也就是工程目录下的类，但是有些时候我们需要加载的类不一定在CLASS_PATH下，比如说它可能在其他文件中，或者说通过网络来获取的，比如说通过socket传来一个类的byte数组，此时我们就需要自定义类加载器，在findClass方法去定义如何去获取byte数组的一个途径。这个是需要自定义类加载器的一个场景。
还有就是，在一些场景下，想要加载的class文件是被加密过的，此时也需要自定义一个类加载器，去完成相关的一些解密的工作。

# String为什么要设置成final
- 安全。String是final的，那么就不存在一些多线程下的写操作问题了，也就是不会发生互相覆盖的问题。还有就是final关键字它本身就有两个和指令重排序相关的规则，进一步保证线程安全
- 效率：String设置为final，再搭配字符串常量池，可以提升效率。因为平常对字符串的操作还是很多的，那设置字符串常量池，需要使用对应对象的时候可以直接去常量池中获取，就可以免去频繁地进行String对象的构建，可以提高效率
- String设置为final，更适合作为key，key-value的那个key。否则如果是可变的话，在定位的时候可能会出现问题，比如说我直接在HashMap里面对一个key进行修改，那么你在不遍历的前提下，无法通过原来的string值获取到value。
# 拦截器与过滤器的区别？
过滤器它是基于Servlet实现的，它其实就是对Servlet中的request和response进行一些过滤，比如说过滤一下非法字符或者添加一些信息都是可以的。一个典型的用法就是可以用来作字符转换，防止乱码。
拦截器它其实就是一种面向切面的思想，在方法调用的前后做一些其他的操作，动态代理其实就是拦截器的一种实现。拦截器它实际上并不依赖于Servlet，它实际上是Spring中的一个部分。
