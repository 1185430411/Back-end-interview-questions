# GC调优思路
其实GC调优首先是从代码问题上去发现问题，比如可以先通过一些jmap指令去查看对象的一些具体存活情况和内存占用，从而去解决一些可能的内存泄漏问题。因为就是说如果代码有比较严重的内存泄漏问题，就算再怎么调整JVM的参数也是治标不治本的做法，因为它迟早会发生问题嘛。
那如果代码上的问题解决了，就可以将思路放在参数设置上了。那其实GC调优是有两个关注点，一个就是GC发生的一个频率，包括Minor GC和Full GC，特别是Full GC，因为Full GC执行时间往往是秒级别的。还有一个就是Stop the World的时间。
对于GC发生的概率如果特别频繁的话，有好几种情况，比如说可以去看新生代的内存是不是设置得太小了，事实上把新生代的内存变大在很多时候也是一种很简单很有用的方法。因为举个例子，如果把新生代扩大一倍，从理论上来说，Minor GC执行频率就会减半。当然新生代扩大一倍，进行标记的时间理论上也增加一倍，但是对于新生代的GC来说，标记并不是主要的时间开销，复制才是主要的时间开销；如果两次GC的执行时间相隔变大了，并且如果对象存活时间都很短，那么可能两次GC之间，大量对象都已经死亡了，那么这样复制操作就更快了。这是能显著地进行优化的。另外把新生代内存变大，对老年代也是有好处的，因为有一个晋升老年代的机制嘛，那两次Minor GC进行的时间间隔长了，对于对象来说，它想要长大一岁的条件就更苛刻了，那么晋升到老年代的对象相对来说也会少，所以Full GC进行得也会不那么频繁。还有就是可以把晋升老年代的年龄阈值适当调大一点，用Minor GC去换取Full GC，也是可以的。
还有就是Stop The World时间太长。比如说对于CMS来说，它有四个执行阶段，其中两个阶段都是需要Stop The World的。其实Remark重新标记这个阶段往往是需要stw比较久的。因为cms虽然说是老年代的收集器，但是在重新标记阶段需要进行全堆扫描，因为可能会存在跨代引用嘛，就是说老年代和新生代的对象互相引用，那么此时是需要进行全堆扫描。如果新生代的对象非常多的话，这个流程就很占时间了。对于这种情况，CMS提供CMSScavengeBeforeRemark参数，可以强制在Remark之前进行一次Minor GC，这样stw的时间就变短了。

# AIO
AIO就是异步非阻塞IO。也就是说它监听到IO事件之后，不需要亲自去处理，而是交由其他线程处理，所以是异步的。在Java中的AIO是基于线程池实现的。也就是说，它一开始还是和NIO一样，需要监听Channel上的IO事件，当IO事件发生时，就会交给线程池中的线程去处理，对于当前线程来说，就可以继续做其他的一些事情，最后可以通过调用FutureTask.get()方法去获取IO事件执行的一个结果，从而达到了异步非阻塞的特点。

# Arrays.sort执行原理？
Arrays.sort其实用了三种排序算法。会根据数组的长度灵活选择不同的排序算法。
有两个阈值 一个是47，一个是286。低于47，会使用插入排序，而位于47与286之间，会使用快速排序，大于286会有两种情况，它会先对数组进行一个判断，判断它是否基本有序，如果基本有序的话，会使用插快速排序，否则就会使用归并排序

# submit方法执行原理
submit方法它有三个重载方法，最常见的用法就是传入一个Callable对象。在submit方法内部，就会把折这个对象封装成一个FutureTast的对象，这个FutureTast，这个FutureTask，它实现了Runnable和Future两个接口，之后再把FutureTask对象作为参数去调用excute方法，最后再把FutureTask对象返回，这个excute方法才是真正地去执行任务的方法。所以说submit方法底层其实是通过调用excute方法去实现的。

# 注解的原理？
注解其实本身就是一个接口，是一个继承Annotation接口的一个特殊接口。
注解它根据生命周期可以分为三类：
- 源代码级别的，永久保存，可以被反射获取
- 仅在java文件中存在，也就是说，这个注解仅仅是用来提示我们开发人员，不会进到class文件里面
- 会进入到class文件里面，但是在类加载阶段会被抛弃

注解它其实本身是基于JDK动态代理实现的。也就是说如果我们通过反射获取注解对象的时候，其实获取到的是一个代理类对象，那对这个代理类的class文件使用javap进行反编译的话就会发现，这个类实现继承了Proxy类，然后实现了注解接口，并且实现了注解中的所有方法，在这些方法里面直接调用了回调函数，也就是一个AnnotatiojnInvocationHandler里面的invoke方法。那其实这个类挺有意思的，它里面维护了一个Map，里面就存了使用这个注解的时候定义值。然后在invoke方法里面，它先去判断这个方法是不是hashCode，toString这些基类方法，如果是的话就直接调用原来的方法，否则的话就会从map中获取再返回，这是它的逻辑。
