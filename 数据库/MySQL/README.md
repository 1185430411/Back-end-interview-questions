## 一.锁
##### 1.InnoDB用的是什么锁模式，分别是哪几种？
	Innodb引擎所使用的是行级锁模式。主要有共享锁，排它锁，意向共享锁，意向排它锁，间隙锁。
	共享锁（S）：允许一个读取数据事务去读一行，同时阻止其他事务获得相同数据集的排它锁。
	排它锁（X）：允许获得排它锁的事务更新数据，同时阻止其他事务获得相同数据集的共享锁和排它写锁。
	意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。
	意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。
	间隙锁：当使用范围条件而不是相等条件进行检索数据的时候，InnoDB会给所有符合条件的索引项加锁（无论这个索引
	项是否存在），而这些不存在，又被加上锁的索引项就成为“间隙”。这样做的目的是防止幻读（在下一次检索时发现插入
	了一条原先没有，但是符合条件的数据），以满足高隔离性的需要。但是给不存在的索引项加上锁很可能会导致INSERT
	操作被堵塞，会造成严重的锁等待。所以在实际开发中，尤其是插入比较多的业务之中，尽量使用相等条件而不是范围
	条件去进行检索
	
参考: [了解下Mysql的间隙锁及产生的原因](https://www.cnblogs.com/wt645631686/p/8324671.html).

##### 2.InnoDB行锁的实现方式？
	InnoDB行锁的实现方式在MySQL与Oracle中有所区别。
	在MySQL中，InnoDB行锁是通过给索引上的索引项加锁来实现的。所以只有通过索引项来检索数据，MySQL才会加上行级锁，
	否则将会使用表锁，会引起并发性能降低或者锁冲突
	在Oracle中，InnoDB行锁是通过在数据块中的数据行加锁来实现的。
	
##### 3.什么时候应该在InnoDB中使用表锁
	主要有两种情景
	1.事务需要对表中的大量数据进行更新，如果使用行锁的话可能会使执行速度降低，其他事务需要进行长时间的锁等待
	或者锁冲突，此时应该使用表锁来提升事务的执行速度
	2.事务涉及多个表的连接，如果使用行锁很可能会造成死锁，造成大量事务回滚，此时应该使用表锁。

##### 4.MyISAM表锁的实现
	MyISAM中的表级锁又两种模式：表共享锁和表独占写锁。
	对MyISAM的读操作，不会堵塞其他用户对同一个表的读请求，但会堵塞用户对同一个表的写请求。
	对MyISAM的写操作，会堵塞其他用户对同一个表的读操作和写操作

参考: [MySQL中的锁（表锁、行锁）](https://www.cnblogs.com/chenqionghe/p/4845693.html).

##### 5.什么是死锁
	当两个事务都需要对方持有的排它锁才能完成事务，导致了循环锁等待，就是死锁。



## 二.引擎（InnoDB与MyISAM）

##### 1.聚集索引和非聚集索引的区别是？
	聚集索引和非聚集索引的共同点是所用的都是B+树索引。主要区别在于：
	1.聚集索引叶节点储存的是数据块，而非聚集索引的叶子节点储存的是数据块的指针。
	2.聚集索引能直接查找数据块，而在非聚集索引上，如果查询列包含了没有被索引覆盖的列，则需要进行二次查询
	（在辅助索引B+树上找到该列对应的主键，然后去主索引B+树上检索到数据块）。
	所以如果查询业务比较多的场景，适合使用聚集索引。而如果需要频繁修改数据值，适合使用非聚集索引，因为聚集
	索引需要移动数据的物理位置
	3.查询，更新操作较多的场景适合用聚集索引，插入操作较多的场景适合用非聚集索引（无需改变物理地址，只需改变
	指针即可）
参考: [原理剖析：InnoDB与MyISAM 聚集索引与非聚集索引](https://blog.csdn.net/qq_28584889/article/details/88778741).
##### 2.InnoDB与MyISAM有哪些主要区别？
	1.MyISAM是非聚集索引，InnoDB是聚集索引。故MyISAM更适合插入的场景，InnoDB更适合查询与更新的场景。?
	2.InnoDB支持事务操作，外键。而MyISAM不支持
	3.InnoDB使用行级锁，MyISAM使用表级锁。但InnoDB使用行级锁并不是确定的。当查询列中出现了没有被索引项
	覆盖的属性时，InnoDB不知道应该锁住哪一行元组，此时就会使用表级锁对全表加锁。
	4.删表的时候。InnoDB不会重新建立表，而是一行行删除。
	5.对于AUTO_INCREMENT字段。InnoDB中必须包含只有该字段的索引，但在MyISAM中，可以和其他字段一起建立
	联合索引
	6.行数查询时，InnoDB不保存行数，而是扫描全表。而MyISAM只需读取保存的行数即可。
	
