## 一.锁
##### 1.InnoDB用的是什么锁模式，分别是哪几种？
	Innodb引擎所使用的是行级锁模式。主要有共享锁，排它锁，意向共享锁，意向排它锁，间隙锁。
	共享锁（S）：允许一个读取数据事务去读一行，同时阻止其他事务获得相同数据集的排它锁。
	排它锁（X）：允许获得排它锁的事务更新数据，同时阻止其他事务获得相同数据集的共享锁和排它写锁。
	意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。
	意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。
	间隙锁：当使用范围条件而不是相等条件进行检索数据的时候，InnoDB会给所有符合条件的索引项加锁（无论这个索引
	项是否存在），而这些不存在，又被加上锁的索引项就成为“间隙”。这样做的目的是防止幻读（在下一次检索时发现插入
	了一条原先没有，但是符合条件的数据），以满足高隔离性的需要。但是给不存在的索引项加上锁很可能会导致INSERT
	操作被堵塞，会造成严重的锁等待。所以在实际开发中，尤其是插入比较多的业务之中，尽量使用相等条件而不是范围
	条件去进行检索
	
参考: [了解下Mysql的间隙锁及产生的原因](https://www.cnblogs.com/wt645631686/p/8324671.html).

##### 2.InnoDB行锁的实现方式？
	InnoDB行锁的实现方式在MySQL与Oracle中有所区别。
	在MySQL中，InnoDB行锁是通过给索引上的索引项加锁来实现的。所以只有通过索引项来检索数据，MySQL才会加上行级锁，
	否则将会使用表锁，会引起并发性能降低或者锁冲突
	在Oracle中，InnoDB行锁是通过在数据块中的数据行加锁来实现的。
	
##### 3.什么时候应该在InnoDB中使用表锁
	主要有两种情景
	1.事务需要对表中的大量数据进行更新，如果使用行锁的话可能会使执行速度降低，其他事务需要进行长时间的锁等待
	或者锁冲突，此时应该使用表锁来提升事务的执行速度
	2.事务涉及多个表的连接，如果使用行锁很可能会造成死锁，造成大量事务回滚，此时应该使用表锁。

##### 4.MyISAM表锁的实现
	MyISAM中的表级锁又两种模式：表共享锁和表独占写锁。
	对MyISAM的读操作，不会堵塞其他用户对同一个表的读请求，但会堵塞用户对同一个表的写请求。
	对MyISAM的写操作，会堵塞其他用户对同一个表的读操作和写操作

参考: [MySQL中的锁（表锁、行锁）](https://www.cnblogs.com/chenqionghe/p/4845693.html).
