### 一.sleep()方法和wait()方法的区别。
sleep方法是Thread类中的静态方法，使调用线程放弃CPU执行权，进行睡眠状态，也就是从运行态转化为阻塞态。sleep()方法需要传入一个long型的参数，单位为毫秒。待休眠时间结束后，线程就从阻塞态转化为就绪态，开始争取CPU时间片；另外要提的是，sleep()方法的执行并不会释放对象锁，如果线程原本持有对象锁，在进入睡眠状态后，依然持有对象锁，其他线程不能获得该对象锁。
wait()方法是Object基础类中的一个非静态方法，所有Object的子孙类对象都有该方法。wait()方法的调用使当前线程挂起，从运行态转化为阻塞态，和sleep方法不一样的是，它不会自动恢复为就绪态，只有当其他线程对该对象执行notify或者notifyAll方法被唤醒时，才会转化为就绪态。另外wait方法的调用会释放线程持有的对象锁，其他线程可以获得该对象锁。所以说，wait方法必须搭配synchronized关键字一起使用，因为synchronized可以获取对象锁。

### 二.为什么wait，notify，notifyAll方法要在synchronized内调用？
这三个方法是Object基础类中的方法，所有Object的子孙类都拥有这些方法。wait方法的实质就是使调用线程挂起，由运行态转化为阻塞态，并且释放对象锁；而notify和notifyAll就是唤醒等待该对象锁的所有线程或者它们的其中一个，并且把对象锁让给它们。所以说，这三个的方法执行的前提，都是要持有对象锁。
而每个对象都有且仅有一个独占锁，线程只有获取该独占锁才能访问synchronized关键字修饰的方法或者代码块，所以进入synchronized代码块的线程都是持有对象锁的，满足这三个方法的调用前提，所以要在synchronized内调用。
而如果不在synchronized内调用，程序也可以通过编译，但是运行的时候会报错。

### 三.start()方法和run()方法的区别是什么？
这两个都是Thread类内的非静态方法。
在创建线程时，如果选择实现Runnable接口或者继承Thread类，都需要重写run方法，run方法内就是线程要执行的任务。
- start方法的调用是同步的，也就是调用该方法会创建新的线程，由线程执行其中的run方法。并且start方法的调用时不可重复的，否则会抛出线程状态不正确的异常。
run方法的调用是异步的，调用该方法不会创建新的线程，而是相当于一个普通的函数，可以比重复调用。因此启动一个线程的正确方法应该是用start方法。
- start方法的调用使线程从新建态转化为就绪态，但并不保证线程会马上执行，因为就绪态的线程还需要等待CPU调度获得时间片后才能够执行其中的run方法执行任务。而新建态向就绪态的转化是单向的，不可逆的，所以这就是为什么重复调用start方法会抛出线程状态错误的异常。
而run方法的调用，如果不是单独调用的话，会让线程从就绪态转化为运行态。
