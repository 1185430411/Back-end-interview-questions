### 一.sleep()方法和wait()方法的区别。
sleep方法是Thread类中的静态方法，使调用线程放弃CPU执行权，进行睡眠状态，也就是从运行态转化为阻塞态。sleep()方法需要传入一个long型的参数，单位为毫秒。待休眠时间结束后，线程就从阻塞态转化为就绪态，开始争取CPU时间片；另外要提的是，sleep()方法的执行并不会释放对象锁，如果线程原本持有对象锁，在进入睡眠状态后，依然持有对象锁，其他线程不能获得该对象锁。
wait()方法是Object基础类中的一个非静态方法，所有Object的子孙类对象都有该方法。wait()方法的调用使当前线程挂起，从运行态转化为阻塞态，和sleep方法不一样的是，它不会自动恢复为就绪态，只有当其他线程对该对象执行notify或者notifyAll方法被唤醒时，才会转化为就绪态。另外wait方法的调用会释放线程持有的对象锁，其他线程可以获得该对象锁。所以说，wait方法必须搭配synchronized关键字一起使用，因为synchronized可以获取对象锁。

### 二.为什么wait，notify，notifyAll方法要在synchronized内调用？
这三个方法是Object基础类中的方法，所有Object的子孙类都拥有这些方法。wait方法的实质就是使调用线程挂起，由运行态转化为阻塞态，并且释放对象锁；而notify和notifyAll就是唤醒等待该对象锁的所有线程或者它们的其中一个，并且把对象锁让给它们。所以说，这三个的方法执行的前提，都是要持有对象锁。
而每个对象都有且仅有一个独占锁，线程只有获取该独占锁才能访问synchronized关键字修饰的方法或者代码块，所以进入synchronized代码块的线程都是持有对象锁的，满足这三个方法的调用前提，所以要在synchronized内调用。
而如果不在synchronized内调用，程序也可以通过编译，但是运行的时候会报错。
