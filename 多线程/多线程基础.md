### 一.sleep()方法和wait()方法的区别。

sleep方法是Thread类中的静态方法，使调用线程放弃CPU执行权，进行睡眠状态，也就是从运行态转化为阻塞态。sleep()方法需要传入一个long型的参数，单位为毫秒。待休眠时间结束后，线程就从阻塞态转化为就绪态，开始争取CPU时间片；另外要提的是，**sleep()方法的执行并不会释放对象锁，如果线程原本持有对象锁，在进入睡眠状态后，依然持有对象锁，其他线程不能获得该对象锁**。
wait()方法是Object基础类中的一个非静态方法，所有Object的子孙类对象都有该方法。wait()方法的调用使当前线程挂起，从运行态转化为阻塞态，和sleep方法不一样的是，它不会自动恢复为就绪态，只有当其他线程对该对象执行notify或者notifyAll方法被唤醒时，才会转化为就绪态。另外wait方法的调用会释放线程持有的对象锁，其他线程可以获得该对象锁。所以说，wait方法必须搭配synchronized关键字一起使用，因为synchronized可以获取对象锁。

### 二.为什么wait，notify，notifyAll方法要在synchronized内调用？

这三个方法是Object基础类中的方法，所有Object的子孙类都拥有这些方法。wait方法的实质就是使调用线程挂起，由运行态转化为阻塞态，并且释放对象锁；而notify和notifyAll就是唤醒等待该对象锁的所有线程或者它们的其中一个，并且把对象锁让给它们。所以说，这三个的方法执行的前提，都是要持有对象锁。
而每个对象都有且仅有一个独占锁，线程只有获取该独占锁才能访问synchronized关键字修饰的方法或者代码块，所以进入synchronized代码块的线程都是持有对象锁的，满足这三个方法的调用前提，所以要在synchronized内调用。
而如果不在synchronized内调用，程序也可以通过编译，但是运行的时候会报错。

### 三.start()方法和run()方法的区别是什么？

这两个都是Thread类内的非静态方法。
在创建线程时，如果选择实现Runnable接口或者继承Thread类，都需要重写run方法，run方法内就是线程要执行的任务。

- start方法的调用是同步的，也就是调用该方法会创建新的线程，由线程执行其中的run方法。并且start方法的调用时不可重复的，否则会抛出线程状态不正确的异常。
  run方法的调用是异步的，调用该方法不会创建新的线程，而是相当于一个普通的函数，可以比重复调用。因此启动一个线程的正确方法应该是用start方法。
- start方法的调用使线程从新建态转化为就绪态，但并不保证线程会马上执行，因为就绪态的线程还需要等待CPU调度获得时间片后才能够执行其中的run方法执行任务。而新建态向就绪态的转化是单向的，不可逆的，所以这就是为什么重复调用start方法会抛出线程状态错误的异常。
  而run方法的调用，如果不是单独调用的话，会让线程从就绪态转化为运行态。

### 四.如何优雅地终止一个线程？

终止一个线程的方法有三种：

- 使用Thread类内的stop方法。这个方法能使当前线程强制终止，包括finally语句块中的任务都不会执行，那么这样会出现一系列问题：比如说文件未关闭或者数据库未关闭。所以stop方法已经不建议使用了。
- 使用volatile标识符。我们在线程内部可以自定义一个用volatile修饰的标识，在线程每次执行（比如说在一个循环内）都要判断该标识符的值是否被修改，如果被修改，则要作好线程终止的准备，比如说关闭资源，然后再终止线程。但这样的方法只能终止一个正在执行的线程，如果线程处于阻塞状态的话，是无法进行标识符的判断的。
- 使用interrupt方法。interrupt方法也能使线程终止，但和stop方法不一样的是，它并不是暴力地让线程终止，而也是通过修改了一个中断信号进行线程间的通信；而目标线程可以通过Thread.interrupted方法来判断自己是否被调用interrupt，同样的，在适合的地方对该方法返回值进行判断，如果返回值为true，则说明需要终止，做好一系列后备工作后线程并终止。而和我们自定义标识符不一样的是，如果对一个正在阻塞状态的线程调用interrupt方法，线程就会提前退出阻塞状态，并抛出InterruptedException异常，我们就可以在catch语句中进行后备处理。

所以说最正确的方法应该是使用interrupt函数。



### 四.volatile关键字的作用？

volatile是java中的一个关键字，用来修饰变量，它提供了比synchronized关键字更轻量的一种同步机制。

在讨论volatile关键字之前，首先要聊一下线程在JVM中的内存模型：一个线程执行的之前，会创建一个只有自己能访问，其他线程无法访问的工作内存，并从主内存从把变量拷贝一份到工作内存之中，每次执行任务需要访问变量的时候，都访问自己工作内存中的变量，而不会访问主内存中的变量。那么这样就会造成线程通信同步问题。如果有其他变量对主内存中的变量进行了修改，而当前线程每次只访问自己工作内存的变量，所以主内存中变量的修改对其来说是不可见的。而使用volatile就能避免这一问题，volatile修饰的变量不会被线程复制到工作内存中，而是每次需要进行访问的时候都去主内存中进行读取。这样就保证变量的修改对每个线程来说都是可见的，而这也正是volatile的作用，就是保证变量的可见性。

但volatile并不能保证原子性，因为volatile是不加锁的轻量级操作，所以无法保证线程安全和操作的原子性。



### 五.什么是原子性、可见性、有序性?

- 原子性：一个操作要么不被中锻，全部执行成功，要么全部执行失败。就叫在这个操作是原子性的。如果一个操作是原子性的，那么在多线程并发的环境下就不会出现变量被错误修改的问题。而非原子性的操作都会导致线程安全问题，需要我们使用同步操作（比如synchronized关键字）来将其变成原子操作。所以原子性是确保线程安全的因素之一
- 可见性：可见性就是指各个线程对变量的修改，对每个线程来说都是可见的。从语法角度来说，就是被volatile关键字修饰的变量具有可见性。其实现原理为：一个线程执行的之前，会创建一个只有自己能访问，其他线程无法访问的工作内存，并从主内存从把变量拷贝一份到工作内存之中，每次执行任务需要访问变量的时候，都访问自己工作内存中的变量，而不会访问主内存中的变量。那么这样就会造成线程通信同步问题。如果有其他变量对主内存中的变量进行了修改，而当前线程每次只访问自己工作内存的变量，所以主内存中变量的修改对其来说是不可见的。而使用volatile就能避免这一问题，volatile修饰的变量不会被线程复制到工作内存中，而是每次需要进行访问的时候都去主内存中进行读取。这样就保证变量的修改对每个线程来说都是可见的
- 有序性：在满足happened-before原则的前提下，为了提高执行效率，编译器和处理器会对指令进行重排序。Java提供了两个关键字volatile和synchronized来保证多线程之间操作的有序性,volatile关键字本身通过加入内存屏障来禁止指令的重排序，而synchronized关键字通过一个变量在同一时间只允许有一个线程对其进行加锁的规则来实现

