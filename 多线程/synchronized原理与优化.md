@[toc]

### synchronized的三种应用方式

- 修饰实例方法：以实例对象作为锁，进入同步代码前需要获得当前实例对象的锁

```java
public synchronized void testSynchronized(){
    System.out.println("hello world");
}
```

- 修饰静态方法：以类对象为锁，进入同步代码块前需要获得当前类对象的锁

```java
public synchronized static void testSynchronized(){
    System.out.println("hello world");
}
```

- 修饰代码块：需要指定一个锁对象(既可以是实例对象，也可以是)

```java
public void testSynchronized(){
    synchronized (this){
    	System.out.println("hello world");
   }
}
```



### 锁对象的对象头与Monitor

在Java虚拟机中，对象在内存中分为三块区域：对象头，实例变量，以及填充数据：

![img](https://images2018.cnblogs.com/blog/1093668/201807/1093668-20180710192315570-1871982316.png)

其中对象头又分为Mark Word与Class Metadata Address两个部分：

|                 Mark Word                  |                    Class Metadata Address                    |
| :----------------------------------------: | :----------------------------------------------------------: |
| 存储对象的hashCode，GC标记以及锁记录等信息 | 存储着指向实例对象所属的类对象的指针，JVM通过该信息判断该对象是哪个类的实例 |

其中Mark Word的锁标志位就记录着当前锁对象的锁级别(偏向锁？轻量锁？重量锁？)若是重量锁，对象头中还会存在一个监视器对象，也就是**Monitor**对象。这个Monitor对象就是实现synchronized的一个关键。、

在Java虚拟机(HotSpot)中，Monitor对象其实就是ObjectMonitor对象，这个对象是一个C++对象，定义在虚拟机源码中。

ObjectMonitor有比较多的属性，但是比较重要的属性有四个：

- _count：计数器。用来记录获取锁的次数。该属性主要用来实现重入锁机制。
- _owner：记录着当前锁对象的持有者线程。
- _WaitSet：队列。当一个线程调用了wait方法后，它会释放锁资源，进入WaitSet队列等待被唤醒。
- _EntryList：队列。里面存放着所有申请该锁对象的线程。

所以一个线程获取锁对象的流程如下：

1.判断锁对象的锁标志位是重量级锁，于是想要获取Monitor对象锁。

2.如果Monitor中的_count属性是0，说明当前锁可用，于是把 _owner 属性设置为本线程，然后把 _count 属性+1。这就成功地完成了锁的获取。

3.如果Monitor中的_count属性不为0，再检查  _owner 属性，如果该属性指向了本线程，说明可以重入锁，于是把 _count 属性再加上1，实现锁的冲入。

4.如果 _owner 属性指向了其他线程，那么该线程进入 _EntryList 队列中等待锁资源的释放。

5.如果线程在持有锁的过程中调用了wait()方法，那么线程释放锁对象，然后进入 _WaitSet 队列中等待被唤醒。



### Java虚拟机对synchronized的优化。

在Java中，锁的等级分为四种：无锁，偏向锁，轻量锁，重量锁。

而synchronized并不是一开始就设定为重量锁 (在jdk1.5之前是这样的，但是在jdk1.6之后，synchronized已经被大幅度地优化，其中就引入了偏向锁和锁膨胀等机制。) 

对于重量锁来说，一旦线程获取失败，就要陷入阻塞状态，并且是操作系统层面的阻塞，这个过程涉及用户态到核心态的切换，是一个开销非常大的操作。而研究表明，线程持有锁的时间是比较短暂的，也就是说，当前线程即使现在获取锁失败，但可能很快地将来就能够获取到锁，这种情况下将线程挂起是很不划算的行为。所以要对"synchronized总是启用重量级锁"这个机制进行优化。

#### 偏向锁

有研究表明，其实在大部分场景都不会发生锁资源竞争，并且锁资源往往都是由一个线程获得的。如果这种情况下，同一个线程获取这个锁都需要进行一系列操作，比如说CAS自旋，那这个操作很明显是多余的。

偏向锁就解决了这个问题。其核心思想就是：一个线程获取到了锁，那么锁就会进入偏向模式，当同一个线程再次请求该锁的时候，无需做任何同步，直接进行同步区域执行。这样就省去了大量有关锁申请的操作。

所以，对于没有锁竞争的场合，偏向锁有很好的优化效果。而如果出现了另一个线程请求该锁，那么此时偏向锁就会失效，发生**锁膨胀**，进化为轻量锁。

#### 轻量锁

轻量锁是针对不同时间段有不同的线程来请求锁，如果同一个时间段出现了锁竞争，那么轻量锁就会膨胀为重量锁。

#### 自旋锁

一般情况下，虚拟机为了避免线程真正地在操作系统层面挂起，在线程请求锁资源失败的时候，并不会真正地阻塞。因为线程持有锁的时间是比较短暂的，很可能在一个不远的将来，当前线程的请求就会成功，所以还引入了一种自旋锁的机制。

自旋锁的核心思想就是：一个线程如果请求锁资源失败，并不会马上陷入阻塞，而是不断重复地申请这个锁资源。从而避免了线程状态切换频繁的开销。但是自旋不会一直进行下去，因为空循环的执行是会消耗CPU资源的，如果长时间自旋获得锁失败，那么就会把该线程挂起。

#### 锁消除

Java虚拟机在进行JIT编译时(简单理解为某段代码第一次被执行时进行编译)，JVM会对上下文进行扫描，如果监测到某个地方不可能存在共享资源竞争的问题，却又使用了锁，那么JVM就会认为这个锁是没有必要的，会将该锁消除。
